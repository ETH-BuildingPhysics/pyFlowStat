'''
TriSurfaceNew.py

New version of TriSurface. TriSurfaceNew will use matplotlib.tri classes
extensively.

!!! Still in alpha version !!!

See domcumention in class definition
'''

import re

import numpy as np
import matplotlib.tri as tri




class TriSurfaceNew(tri.Triangulation):
    '''
    class TriSurfaceNew
    '''
    
    def __init__(self, x, y, z, triangles=None, mask=None):
        '''
        base constructor
        '''
        tri.Triangulation.__init__(self, x, y, triangles=None, mask=None)
        
        self.z = z
        self.data = dict()

        
    @classmethod
    def readFromFoamFile(self,varsFile,pointsFile,facesFile,viewAnchor,viewBasis):
        pass
        
    
    
    
    
class affineTransfomatrion(object):
    '''
    A affine transfomation is define as y = A*x + b.
    
    srcCoorSys = [[],]
    '''
    
    def __init__(self,srcBasisSrc,tgtBasisSrc,tgtAnchorSrc):
        
        translation = tgtAnchorSrc-np.zeros(3)
        
        # get the matrix (shape 4) of the affine transfomation ()
        self.invM = self.affineMat(tgtBasisSrc,translation)
        self.M= np.linalg.inv(invM)

        return T,invT,viewBasis

#    def affineVec(self,vec):
#        '''
#        Return affine vector from standard vector
#        
#        Arguments:
#            * vec: [np.array. trans.shape=(3)] a vector
#        
#        Return:
#            * affineVec [np.array. affineMat.shape=(4)] the affine Vector. Same as vec, but with a trailing 1.
#        '''
#        affineVec = np.zeros(len(vec)+1)
#        affineVec[-1] = 1
#        affineVec[0:len(vec)] = affineVec[0:len(vec)]+vec
#        return affineVec
#
#    
    def affineMat(self,mat,trans):
        '''
        Return affine matrix from standard matrix.
        
        Arguments:
            * mat: [np.array. mat.shape=(3,3)] a matrix.
            * trans: [np.array. trans.shape=(3)] translation vector from Sbasis to Vbasis, express in Sbasis.
        
        Return:
            * affineMat [np.array. affineMat.shape=(4,4)] the affine Matrix.
        '''
        nbl = mat.shape[0]  #number of line
        nbr = mat.shape[0]  #number of row
        affineMat = np.zeros((nbl+1,nbr+1))
        affineMat[0:nbl,0:nbl] = affineMat[0:nbl,0:nbl]+mat
        affineMat[0:nbr,-1] = affineMat[0:nbr,-1] + trans
        affineMat[-1,-1] = 1
        return affineMat


def parseFoamFile(foamFile):
    '''
    Parse a foamFile generated by the OpenFOAM sample tool or sampling library.
    
    Note:
        * It's a primitiv parse, do not add header in your foamFile!
        * Inline comment are allowed only from line start. c++ comment style.
        
    Arguments:
        * foamFile: [str()] Path of the foamFile

    Returns:
        * output: [numpy.array()] data store in foamFile
    '''
    output = []
    catchFirstNb = False
    istream = open(foamFile, 'r')
    for line in istream: 
        # This regex finds all numbers in a given string.
        # It can find floats and integers writen in normal mode (10000) or with power of 10 (10e3).
        match = re.findall('[-+]?\d*\.?\d+e*[-+]?\d*', line)
        if (line.startswith('//')):
            pass
        if (catchFirstNb==False and len(match)==1):
            catchFirstNb = True
        elif (catchFirstNb==True and len(match)>0):
            matchfloat = list()
            for nb in match:                
                matchfloat.append(float(nb))
            output.append(matchfloat)
        else:
            pass
    istream.close()
    return np.array(output)  