'''
TriSurface.py

Class TriSruface holds a planar surface, which hols a discret field. The discret field
can by unstructured.

In the foamFiles, the plane in define in base a={a1,a2,a3} (standard normed orthogonal base)
base

'''
import re

import numpy as np


class TriSurface(object):
    """TriSurface Class"""
    
    def __init__(self,storeMesh=True):
        # should the mesh be stored in this object?
        self.storeMesh = storeMesh       
        
        #input path for vars, points and faces
        self.varsFile = str()
        self.pointsFile = str()
        self.facesFile = str()
        
        # vars, point and faces (poits in original basis, not in tilted basis)
        self.vars = None
        self.varRank = int()
        self.points = None   
        self.xys = None
        self.faces = None
        
        # data of the plane in original basis
        self.plDef = None

        # transfomation matrix and vector to display data into the alternate point of view
        self.viewAnchor = None  #view anchor
        self.viewBasis = None   #view basis     
        self.tranVec = None     #translation vectoc
        self.rotMat = None      #rotation matrix
        self.affMat = None      #affine transformation (from standard basis to view basis)
        self.invAffMat = None   # inverse of affine transformation matrix
        
        
#        self.viewBasis = np.zeros((3,3))
#        if viewBasis2D==None:
#            pass
#        else:
#            self.viewBasis[:,0] = viewBasis2D[:,0]
#            self.viewBasis[:,1] = viewBasis2D[:,2]
        
    def parseFoamFile(self,foamFile):
        '''
        Parse a foamFile generated by the OpenFOAM sample tool or sampling library.
        
        Note:
            * It's a primitiv parse, do not add header in your foamFile!
            * Inline comment are allowed only from line start. c++ comment style.
            
        Arguments:
            * foamFile: [str()] Path of the foamFile

        Returns:
            * output: [numpy.array()] data store in foamFile
        '''
        output = []
        catchFirstNb = False
        istream = open(foamFile, 'r')
        for line in istream: 
            # This regex finds all numbers in a given string.
            # It can find floats and integers writen in normal mode (10000) or with power of 10 (10e3).
            match = re.findall('[-+]?\d*\.?\d+e*[-+]?\d*', line)
            if (line.startswith('//')):
                pass
            if (catchFirstNb==False and len(match)==1):
                catchFirstNb = True
            elif (catchFirstNb==True and len(match)>0):
                matchfloat = list()
                for nb in match:                
                    matchfloat.append(float(nb))
                output.append(matchfloat)
            else:
                pass
        istream.close()
        return np.array(output)


    def readFromFoamFile(self,varsFile,pointsFile,facesFile,viewAnchor,xViewBasis,yViewBasis):
        # this method acts almost like a constructor
        '''
        Read planar surface generated by the OpenFOAM sample tool or sampling library.
        
        Notes:
            * See notes of TriSurface.parseFoamFile()
            
        Arguments:
            * varsFile:   [str()] Path of the foamFile with variable
            * pointsFile: [str()] Path of the foamFile with points
            * facesFile:  [str()] Path of the foamFile with faces

        Modified members:
            * vars:   [numpy.array()] list of variables
            * points: [numpy.array()] list of points
            * faces:  [numpy.array()] list of faces. Delaunay tress
        
        test
        '''
        self.varsFile = varsFile
        self.pointsFile = pointsFile
        self.facesFile = facesFile
        # read variable
        self.vars = self.parseFoamFile(varsFile)
        self.varRank = len(self.vars[1,:])
        # read mesh if needed and generate tansformation data (mendatory)   
        if self.storeMesh==True:
            self.points = self.parseFoamFile(pointsFile)
            self.faces = self.parseFoamFile(facesFile)[:,1:4]
            self.plDef = self.genPlaneData(self.points)
            # generate transformation stuff with points, viewAnchor and view Basis
            self.viewAnchor  = viewAnchor
            self.affMat,self.invAffMat,self.viewBasis = self.genTransData(self.points,self.viewAnchor,xViewBasis,yViewBasis)           
            # generate planar coordinate X and Y
            self.xys = np.zeros((self.points.shape[0],2))
            for i in range(self.xys.shape[0]):
                ptInA = self.points[i,:]
                ptInB = np.dot(self.affMat , self.affineVec(ptInA).reshape((4,1)))[0:3]
                ptInB = np.dot(self.affMat , self.affineVec(ptInA))[0:3]
                self.xys[i,:] = ptInB[0:2]
        else:
            points = self.parseFoamFile(pointsFile)
            self.plDef = self.getPlaneData(points)
            # generate transformation stuff with points, viewAnchor and view Basis   
            self.viewAnchor  = viewAnchor
            self.affMat,self.invAffMat,self.viewBasis = self.genTransData(points,self.viewAnchor,xViewBasis,yViewBasis)
                
   
    def readFromVTK(self,vtkFile):
        '''
        read planar surface from OpenFOAM. In vtk format.
        /!\ Not impemented /!\ 
        '''
        pass

    
    def getVar(self,point,interpolation='linear',pointBasis='default',points=None,faces=None,):
        '''
        Return "var" at location "point" according "interpolation". "interpolation" can be one of
        the following:
            * nearest
            * linear (default)
            * cubic
        
        Notes:
            * If storeMesh=True, then "points" and "faces" included in the object are used.
            * If storeMesh=Flase, then "points" and "faces" must be passed with points and faces.
        
        Return:
            * var: [numpy.array or float, depending variable rank] variable value at location "point"
        
        /!\ Not impemented /!\ 
        '''
        pass
     
    
    
    # collection of tool to manipulate point list, plane, vector and matrix    
    def genPlaneData(self,points):
        '''
        ''' 
        # get the plane normal from list of points define with basis orig
        v1 = points[1,:]-points[0,:]
        v2 = points[2,:]-points[0,:]
        plNorm = np.cross(v1,v2)
        
        # get vector which define the plane in space
        plDef = np.zeros(4)
        plDef[0:3] = plDef[0:3]+plNorm
        afpt = self.affineVec(points[0,:])
        c = np.dot(plDef,afpt)
        plDef[3] = -c
        return plDef
        
    def genTransData(self,points,viewAnchor,xViewBasis,yViewBasis):
        '''
        '''         
        viewBasis = np.zeros((3,3))
        zViewBasis = np.cross(xViewBasis,yViewBasis)
        viewBasis[:,0] = xViewBasis        
        viewBasis[:,1] = yViewBasis
        viewBasis[:,2] = zViewBasis
        
        # get affine matrix of the transformation
        #   A is the orignal basis of the plane, namely: the standard basis (A =np.identity(3))
        #   B is the view basis. x and y are the in plane, z is the normal. z also define the view direction
        #   for a given vecto V:
        #       VinB stands for V decribes with basis B
        #       VinA stands for V decribes with basis A  

        # T = affine tranformation matrix from A->B.
        #   T*VinA = VinB
        #   invT*VinB = VinA
        translation = viewAnchor-np.zeros(3)
        invT = self.affineMat(viewBasis,translation)
        T = np.linalg.inv(invT)

        return T,invT,viewBasis

            

    def affineVec(self,vec):
        '''
        return vec in affine coordinate
        '''
        affineVec = np.zeros(len(vec)+1)
        affineVec[-1] = 1
        affineVec[0:len(vec)] = affineVec[0:len(vec)]+vec
        return affineVec
    
    def affineMat(self,mat,trans):
        '''
        return affine matrix from standard matrix
        '''
        nbl = mat.shape[0]  #number of line
        nbr = mat.shape[0]  #number of row
        affineMat = np.zeros((nbl+1,nbr+1))
        affineMat[0:nbl,0:nbl] = affineMat[0:nbl,0:nbl]+mat
        affineMat[0:nbr,-1] = affineMat[0:nbr,-1] + trans
        affineMat[-1,-1] = 1
        return affineMat
        
    def isColinear(self,vec1,vec2):
        '''
        return true if vec1 and vec2 are coplanar
        '''
        if np.cross(vec1,vec2)==np.zeros(len(vec1)):
            return True
        else:
            return False
        
        
        
        
        
        
         