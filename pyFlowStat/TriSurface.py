'''
TriSurface.py

Class TriSruface holds a planar surface, which hols a discret field. The discret field
can by unstructured.

In the foamFiles, the plane in define in base a={a1,a2,a3} (standard normed orthogonal base)
base

'''
import re

import numpy as np
import scipy as sp
import scipy.spatial as spsp   #include Delaunay tesselation for grid generation


class TriSurface(object):
    """TriSurface Class"""
    
    def __init__(self,storeMesh=True):
        # should the mesh be stored in this object?
        self.storeMesh = storeMesh       
        
        #input path for vars, points and faces
        self.varsFile = str()
        self.pointsFile = str()
        self.facesFile = str()
        
        # vars, point and faces (poits in original basis, not in tilted basis)
        self.vars = []
        self.points = []
        self.faces = []
        self.varRank = int()
        
        # transfomation matrix and vector to display data into the alternate point of view
        self.flipView = False
        self.viewAnchor = []  #
        self.viewVec = []    #vew vector
        self.tranVec = []    #translation vectoc
        self.rotMat = []    #rotation matrix
        self.affMat = []    #affine transformation
        
    def parseFoamFile(self,foamFile):
        '''
        Parse a foamFile generated by the OpenFOAM sample tool or sampling library.
        
        Note:
            * It's a primitiv parse, do not add header in your foamFile!
            * Inline comment are allowed only from line start. c++ comment style.
            
        Arguments:
            * foamFile: [str()] Path of the foamFile

        Returns:
            * output: [numpy.array()] data store in foamFile
        '''
        output = []
        catchFirstNb = False
        istream = open(foamFile, 'r')
        for line in istream: 
            # This regex finds all numbers in a given string.
            # It can find floats and integers writen in normal mode (10000) or with power of 10 (10e3).
            match = re.findall('[-+]?\d*\.?\d+e*[-+]?\d*', line)
            if (line.startswith('//')):
                pass
            if (catchFirstNb==False and len(match)==1):
                catchFirstNb = True
            elif (catchFirstNb==True and len(match)>0):
                matchfloat = list()
                for nb in match:                
                    matchfloat.append(float(nb))
                output.append(matchfloat)
            else:
                pass
        istream.close()
        return np.array(output)

    def readFromFoamFile(self,varsFile,pointsFile,facesFile=None):
        '''
        Read planar surface generated by the OpenFOAM sample tool or sampling library.
        
        Notes:
            * See notes of TriSurface.parseFoamFile()
            
        Arguments:
            * varsFile:   [str()] Path of the foamFile with variable
            * pointsFile: [str()] Path of the foamFile with points
            * facesFile:  [str()] Path of the foamFile with faces (optional but strongly recommanded)

        Modified members:
            * vars:   [numpy.array()] list of variables
            * points: [numpy.array()] list of points
            * faces:  [numpy.array()] list of faces. Delaunay tress
        
        test
        '''
        # read variable
        self.vars = self.parseFoamFile(varsFile)
        self.varRank = len(self.vars[1,:])
        # read mesh
        if self.storeMesh==True:
            self.points = self.parseFoamFile(pointsFile)
            self.getPlaneData()
            if facesFile==None:
                self.faces = self.createTriangle()
            else:
                #remove the first number which indicate the number of points (allwas triangles)
                self.faces = self.parseFoamFile(facesFile)[:,1:4]

    
    def readFromVTK(self,vtkFile):
        '''
        read planar surface from OpenFOAM. In vtk format.
        /!\ Not impemented /!\ 
        '''
        pass

   
    def createTriangle(self,points=None):
        '''
        create a Delauney triangles from self.points if not exist. Store the
        triangle in self.faces.
      
        '''
        popDim = int()
        for i in range(len(self.plNorm)):
            if self.plNorm[i]!=0:
                popDim = i
        
        def getPoints2D(popDim,points):
            points2D = np.zeros([points.shape[0],2])
            if popDim==0:
                points2D = np.hstack((points[:,1] , points[:,2]))
            elif popDim==1:
                points2D = np.hstack((points[:,0] , points[:,2]))
            else:
                points2D = np.hstack((points[:,2] , points[:,3]))
            return points2D
            
        if self.storeMesh==True:
            self.faces = spsp.Delaunay(getPoints2D(popDim,self.points))
        else:
            return spsp.Delaunay(getPoints2D(popDim,points))
    
    def getVar(self,point,interpolation='linear',pointBasis='default',points=None,faces=None,):
        '''
        Return "var" at location "point" according "interpolation". "interpolation" can be one of
        the following:
            * nearest
            * linear (default)
            * cubic
        
        Notes:
            * If storeMesh=True, then "points" and "faces" included in the object are used.
            * If storeMesh=Flase, then "points" and "faces" must be passed with points and faces.
        
        Return:
            * var: [numpy.array or float, depending variable rank] variable value at location "point"
        
        /!\ Not impemented /!\ 
        '''
        pass
     
    
    
    def getPlaneData(self):
        '''
        Return 
            * pln: [np.array] plane normal
            * to be completed if needed...
        '''
        # normal
        v1 = self.points[1,:]-self.points[0,:]
        v2 = self.points[2,:]-self.points[0,:]
        self.plNorm = np.cross(v1,v2)
        
        
    
        
        
        
        
         