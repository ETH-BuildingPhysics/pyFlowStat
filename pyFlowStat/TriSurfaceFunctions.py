'''
TriSurfaceFunctions.py

Collection of functions for the following classes:
    * TriSurfaceMesh
    * TriSurfaceScalar
    * TriSurfaceVector
    * TriSurfaceSymmTensor
    * TriSurfaceTensor (to be implemented)
    
Functions included:
    * getSubTriSurfaceMesh
    * compressArray
    * getSubTriSurfaceVector
    * getSubTriSurfaceVectorList
    * saveTriSurfaceList_hdf5
    * loadTriSurfaceMesh_hdf5Parser
    * loadTriSurfaceVectorList_hdf5Parser
    * loadTriSurfaceVector_hdf5Parser
    * parseFoamFile_sampledSurface
    * parseVTK_ugly_sampledSurface
    
For documentation, see the docstring included in each function.
'''
#=============================================================================#
# load modules
#=============================================================================#
import h5py

import numpy as np

import matplotlib.tri as tri
import matplotlib.path as mplPath

#import pyFlowStat.CoordinateTransformation as coorTrans
import pyFlowStat.TriSurface as TriSurface
import pyFlowStat.TriSurfaceMesh as TriSurfaceMesh
import pyFlowStat.TriSurfaceVector as TriSurfaceVector



#=============================================================================#
# functions
#=============================================================================#
def getSubTriSurfaceMesh(tsmSource, poly, op='in', mode='mid'):
    '''
    Return a sub TriSurfaceMesh defined inside or outside a polygon. This is
    a helper function. Use better getSubTriSurfaceVector.    
    
    Arguments:
        *tsmSource*: TriSurfaceMesh Object
        
        *poly*: numpy array of shape (N,2)
         list of N points of the polygon. Example for a square made by the
         points pt1, pt2, pt3 and pt4:
         >>> poly = np.array([[x1,y1],[x2,y2],[x3,y3],[x4,y4]])
         
        *op*: python string ('in' or 'out'). Default='in'
         Keep the triangles inside or outside the polygon

    Returns:
        *tsm*: TriSurfaceMesh object.

        *node_renum*: 
         Node renumbering. Useful for the compression of the data
    '''
    # create a boundBox from the polygon
    maskedTri = np.zeros(tsmSource.triangles.shape[0])
    bb = mplPath.Path(poly)
    
    # define the operation
    inPoly = None
    outPoly = None
    if op=='in':
        inPoly = 0
        outPoly = 1
    elif op=='out':
        inPoly = 1
        outPoly = 0
    else:
        raise ValueError('Argument "op" must be "in" or "out".')

    # define the mask and apply it.
    if mode=='each':
        xtri = tsmSource.x[tsmSource.triangles]
        ytri = tsmSource.y[tsmSource.triangles]
        for i in range(maskedTri.shape[0]):
            if np.sum(bb.contains_points(np.vstack((xtri[i],ytri[i])).T))>0:
                maskedTri[i] = inPoly
            else:
                maskedTri[i] = outPoly
    elif mode=='mid':
        xmid = tsmSource.x[tsmSource.triangles].mean(axis=1)
        ymid = tsmSource.y[tsmSource.triangles].mean(axis=1)
        for i in range(maskedTri.shape[0]):
            if bb.contains_point([xmid[i],ymid[i]])==1:
                maskedTri[i] = inPoly
            else:
                maskedTri[i] = outPoly
    else:
        raise ValueError('Argument "mode" must be "each" or "mid".')
    
    tsmSource.triangulation.set_mask(maskedTri)
    
    #compress the triangles and create a new TriSurface mesh
    trianalyzer = tri.TriAnalyzer(tsmSource.triangulation)
    (comp_triangles,comp_x,comp_y,node_renum) = trianalyzer._get_compressed_triangulation(return_node_renum=True)

    comp_z = compressArray(tsmSource._TriSurfaceMesh__z,node_renum)

    subTsm = TriSurfaceMesh.TriSurfaceMesh(x=comp_x,
                                           y=comp_y,
                                           z=comp_z,
                                           triangles=comp_triangles,
                                           mask=None,
                                           affTrans=tsmSource.affTrans,
                                           linTrans=tsmSource.linTrans)

    # remove the mash from the source
    tsmSource.triangulation.set_mask(None)   
    
    return subTsm,node_renum


def compressArray(z,node_renum):
    '''
    Compress an array z according the node renumbering list produced by the
    function getSubTriSurfaceMesh. See "getSubTriSurfaceMesh" and
    "getSubTriSurfaceVector" to learn about node_renum.
    
    Arguments:
        *z*: numpy array of shape (N,)
         The array to compress.
         
        *node_renum*: numpy array
         Node renumbering list generated by getSubTriSurfaceMesh or
         getSubTriSurfaceVector

    Returns:
        *comp_z*: numpy array of shape (M,)
         Compressed array    
    '''
    node_mask = (node_renum == -1)
    z[node_renum[~node_mask]] = z
    z = z[~node_mask]
    return z

   
def getSubTriSurfaceVector(tsvSource, poly, op='in', mode='mid',return_node_renum=False):
    '''
    Return a sub TriSurfaceVector (subTsv) from a TriSurfaceVector source.
    The sub part is cut out of a polygon. The part inside or ouside the 
    polygon can be kept. getSubTriSurfaceVector does not extract a sub-data
    stored in tsvSource.data. To do so, switch return_node_renum to True, and
    use the node_renum output to feed the function compressArray.
    
    Arguments:
        *tsvSource*: TriSurfaceVector Object
        
        *poly*: numpy array of shape (N,2)
         list of N points of the polygon. Example for a square made by the
         points pt1, pt2, pt3 and pt4:
         >>> poly = np.array([[x1,y1],[x2,y2],[x3,y3],[x4,y4]])
         
        *op*: python string ('in' or 'out'). Default='in'
         Keep the triangles inside or outside the polygon
         
        *return_node_renum*: python bool. Default=False
         If True, returns the node renumbering. Useful to compress array with
         TriSurfaceFunctions.compressArray()
         
    Returns:
        *subTsm*: TriSurfaceMesh object
        
        *subTsv*: TriSurfaceVector object
        
        *node_renum*: numpy array. Returned only if return_node_renum=True        
    '''
    subTsm,node_renum = getSubTriSurfaceMesh(tsmSource=tsvSource.triSurfaceMesh,
                                             poly=poly,
                                             op=op,
                                             mode=mode)
    
    comp_vx = compressArray(tsvSource.vx,node_renum)
    comp_vy = compressArray(tsvSource.vy,node_renum)
    comp_vz = compressArray(tsvSource.vz,node_renum)

    subProjectedField = tsvSource.projectedField

    subTsv = TriSurfaceVector.TriSurfaceVector(vx=comp_vx,
                                               vy=comp_vy,
                                               vz=comp_vz,
                                               time=tsvSource.time,
                                               triSurfaceMesh=subTsm,
                                               projectedField=subProjectedField,
                                               interpolation=None,
                                               kind=None)
 
    if return_node_renum==False:
        return subTsm, subTsv
    elif return_node_renum==True:
        return subTsm, subTsv, node_renum


def getSubTriSurfaceVectorList(tsvListSource,
                               poly,
                               op='in',
                               mode='mid',
                               return_node_renum=False):
    '''
    Same as getSubTriSurfaceVector, but with a list of TriSurfaceVector list.
    
    Arguments:
        *tsvSource*: python list of lense N.
         List of source TriSurfaceVector Object.
        
        *poly*: numpy array of shape (N,2)
         list of N points of the polygon. Example for a square made by the
         points pt1, pt2, pt3 and pt4:
         >>> poly = np.array([[x1,y1],[x2,y2],[x3,y3],[x4,y4]])
         
        *op*: python string ('in' or 'out'). Default='in'
         Keep the triangles inside or outside the polygon
         
        *return_node_renum*: python bool. Default=False
         If True, returns the node renumbering. Useful to compress array with
         TriSurfaceFunctions.compressArray()
         
    Returns:
        *subTsm*: TriSurfaceMesh object
        
        *subTsvList*: python list of lense N.
         List of sub TriSurfaceVector object
        
        *node_renum*: numpy array. Returned only if return_node_renum=True      
    '''    
    subTsm,node_renum = getSubTriSurfaceMesh(tsmSource=tsvListSource[0].triSurfaceMesh,
                                             poly=poly,
                                             op=op,
                                             mode=mode)

    subTsvList = []    
    
    for tsvSource in tsvListSource:
        comp_vx = compressArray(tsvSource.vx,node_renum)
        comp_vy = compressArray(tsvSource.vy,node_renum)
        comp_vz = compressArray(tsvSource.vz,node_renum)
    
        subProjectedField = tsvSource.projectedField
    
        subTsv = TriSurfaceVector.TriSurfaceVector(vx=comp_vx,
                                                   vy=comp_vy,
                                                   vz=comp_vz,
                                                   time=tsvSource.time,
                                                   triSurfaceMesh=subTsm,
                                                   projectedField=subProjectedField,
                                                   interpolation=None,
                                                   kind=None)
        subTsvList.append(subTsv)
        
    if return_node_renum==False:
        return subTsm, subTsvList
    elif return_node_renum==True:
        return subTsm, subTsvList, node_renum

        
   
def saveTriSurfaceList_hdf5(triSurfaceList,varName,hdf5file,extraVar=[],indexingMode='time'):
    '''
    Save a list of TriSurface<type> in a hdf5 file.
    
    Arguments:
        *triSurfaceList*: python list
         Python list of TriSurface<type> objects.
         
        *varName* python string.
         Name of the variable <type>.
        
        *hdf5file*: python string
         Name of the target hdf5 file. It can also include the path.
         
        *extraVar*: python list of string.
         TriSurface<type> can holds extra data in the dict TriSurface<type>.data.
         Use extraVar to include them. Default=[] (empty list).
         
        *indexingMode*: python string
         Defines the key of each surfaces saved in the hdf5. Can be 'time' or
         'index'. Delault='time'.
         
    Returns:
        None
    '''
    fwm = h5py.File(hdf5file, 'w-')
    
    #save the surface mesh
    gName = 'mesh'
    gMesh = fwm.create_group(gName)

    gMesh.create_dataset('points',data=triSurfaceList[0].rawPoints())
    gMesh.create_dataset('faces',data=triSurfaceList[0].triangles)
    
    for i in range(len(triSurfaceList)):
        # group name
        gName = str()
        if indexingMode=='time':
            gName = str(triSurfaceList[i].time)
        elif indexingMode=='index':
            gName = str(i)
        else:
            raise ValueError('Argument "indexingMode" must be "time" or "index".')
        
        gsurfi = fwm.create_group(gName)

        # save  data
        gsurfi.create_dataset('time',data=triSurfaceList[i].time)
        gsurfi.create_dataset(varName,data=triSurfaceList[i].rawVars())
        
        if len(extraVar)!=0:
            for var in extraVar:
                gsurfi.create_dataset(var,data=triSurfaceList[i][var])
        
    fwm.close()


def loadTriSurfaceMesh_hdf5Parser(hdf5Parser,
                                  viewAnchor,
                                  xViewBasis,
                                  yViewBasis,
                                  srcBasisSrc=[[1,0,0],[0,1,0],[0,0,1]]):
    '''
    Helper function. See loadTriSurfaceVectorList_hdf5.
    '''
    # create the transformation objects
    afftrans, lintrans = TriSurface.getTransformation(viewAnchor=viewAnchor,
                                                      xViewBasis=xViewBasis,
                                                      yViewBasis=yViewBasis,
                                                      srcBasisSrc=srcBasisSrc)
  
    # get mest data
    gName = 'mesh'
    points = hdf5Parser[gName]['points'].value
    triangles = hdf5Parser[gName]['faces'].value
    
    ptsSrc = points
    ptsTgt = np.zeros((ptsSrc.shape[0],ptsSrc.shape[1]))
    for i in range(ptsSrc.shape[0]):
        ptsTgt[i,:] = afftrans.srcToTgt(ptsSrc[i,:])
    
    tsm = TriSurfaceMesh.TriSurfaceMesh(x=ptsTgt[:,0],
                                        y=ptsTgt[:,1],
                                        z=ptsTgt[:,2],
                                        triangles=triangles,
                                        mask=None,
                                        affTrans=afftrans,
                                        linTrans=lintrans)
    return tsm    


def loadTriSurfaceVector_hdf5Parser(hdf5Parser,
                                    varName,
                                    time,
                                    TriSurfaceMesh,
                                    extraVar=[],
                                    projectedField=False):
    '''
    '''
    gName = str(time)
    try:
        time = hdf5Parser[gName]['time'].value
        data = hdf5Parser[gName][varName].value 
    except:
        print('Field '+varName+' in time '+gName+' does not exist. Skip.')


    #get vectors (in vecsTgt)
    vecsSrc = data
    vecsTgt = np.zeros((vecsSrc.shape[0],vecsSrc.shape[1]))
    if projectedField==True:
        for i in range(vecsSrc.shape[0]):
            vecsTgt[i,:] = TriSurfaceMesh.lintrans.srcToTgt(vecsSrc[i,:])
    else:
        vecsTgt = vecsSrc
    
    tsv = TriSurfaceVector.TriSurfaceVector(vx=vecsTgt[:,0],
                                            vy=vecsTgt[:,1],
                                            vz=vecsTgt[:,2],
                                            time=time,
                                            triSurfaceMesh=TriSurfaceMesh,
                                            projectedField=projectedField,
                                            interpolation=None,
                                            kind=None,)
    if len(extraVar)!=0:
        for var in extraVar:
            tsv.data[var] = hdf5Parser[gName][var].value 
    return tsv


def loadTriSurfaceVectorList_hdf5Parser(hdf5Parser,
                                        varName,
                                        TriSurfaceMesh,
                                        extraVar=[],
                                        projectedField=False):
    '''
    Helper function. See loadTriSurfaceVectorList_hdf5.
    '''
    # create the TriSurface list
    triSurfaceList = []
    keys = hdf5Parser.keys()
    keys.sort()
    try:
        keys.pop(keys.index('mesh'))
    except:
        pass
    
    for key in keys:
        tsv = loadTriSurfaceVector_hdf5Parser(hdf5Parser=hdf5Parser,
                                              varName=varName,
                                              time=key,
                                              TriSurfaceMesh=TriSurfaceMesh,
                                              extraVar=extraVar,
                                              projectedField=projectedField)
        
        
        triSurfaceList.append(tsv)
        
        
    return triSurfaceList


def loadTriSurfaceVectorList_hdf5(hdf5file,
                                  varName,
                                  viewAnchor,
                                  xViewBasis,
                                  yViewBasis,
                                  extraVar=[],
                                  srcBasisSrc=[[1,0,0],[0,1,0],[0,0,1]],
                                  projectedField=False):
    '''
    Load all (N) TriSurfaceVectors stored in "hdf5file". the TriSurfaceMesh
    object associated to the surfaces is also returned.
    
    Arguments:
    
    Returns:
        *tsvList*: python list with N entries
         List filled with TriSurfaceVector objects.
         
        *tsm* TriSurfaceMesh object
    '''
    # open the hdf5 parser
    fr = h5py.File(hdf5file, 'r')
    
    # load the mesh
    tsm = loadTriSurfaceMesh_hdf5Parser(hdf5Parser=fr,
                                        viewAnchor=viewAnchor,
                                        xViewBasis=xViewBasis,
                                        yViewBasis=yViewBasis,
                                        srcBasisSrc=srcBasisSrc)
    
   
    tsvList = loadTriSurfaceVectorList_hdf5Parser(hdf5Parser=fr,
                                                  varName=varName,
                                                  TriSurfaceMesh=tsm,
                                                  extraVar=extraVar,
                                                  projectedField=projectedField)  
   
    fr.close()    
    return tsvList, tsm
